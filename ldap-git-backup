#!/usr/bin/perl
# vim: set filetype=perl :
use Modern::Perl;
use English qw( -no_match_vars);
use Carp;

main() unless caller(0);

sub main {
    use Pod::Usage;
    use Getopt::Long;

    my $ldif_cmd = '/usr/sbin/slapcat';
    my $backup_dir = '/var/backup/ldap';
    my $help;
    GetOptions(
        'ldif-cmd=s'   => \$ldif_cmd,
        'backup-dir=s' => \$backup_dir,
        'help'         => \$help,
    );
    pod2usage('-verbose' => 2, '-exit_status' => 0) if $help;
    pod2usage() if @ARGV;

    my $ldif_aref = LDAP::Utils::read_ldif($ldif_cmd);
}

1;

package LDAP::Utils;
use Modern::Perl;
use English qw( -no_match_vars);
use Carp;
use MIME::Base64;

sub read_ldif {
    my ($ldif_cmd) = @_;

    my $entry_count = -1;
    my $ldif_aref = [];
    until ($entry_count == @$ldif_aref) {
        $entry_count = @$ldif_aref;
        $ldif_aref = read_ldif_raw($ldif_cmd);
    }

    return $ldif_aref;
}

sub read_ldif_raw {
    my ($ldif_cmd) = @_;

    my $ldif_aref = [];
    my $ldif_fh;
    local $INPUT_RECORD_SEPARATOR = "\n\n";

    open( $ldif_fh, '-|', $ldif_cmd) or die "Can't exec '$ldif_cmd': $!";
    while (my $record = <$ldif_fh>) {
        push(@$ldif_aref, $record);
    }
    close($ldif_fh) or die "$ldif_cmd exited with $?: $!";

    return $ldif_aref;
}

sub dn {
    my ($ldif) = @_;

    for my $line (split("\n", $ldif)) {
        next unless $line =~ m{\A dn:}xms;
        my $dn;
        if ( $line =~ m{\A dn::}xms ) {
            $dn = ( split(':: ', $line, 2) )[1];
            $dn = decode_base64($dn);
        }
        else {
            $dn = ( split(': ', $line, 2) )[1];
        }
        return canonicalize_dn($dn);
    }

    return '';
}

sub canonicalize_dn {
    my ($dn) = @_;

    my @rdns = split(',', $dn);
    @rdns = map { canonicalize_rdn($_) } @rdns;
    return join(',', @rdns);
}

sub canonicalize_rdn {
    my ($rdn) = @_;

    my ($key, $value) = split('=', $rdn, 2);
    $key   =~ s{\A\s+}{}xms;
    $key   =~ s{\s+\Z}{}xms;
    $value =~ s{\A\s+}{}xms;
    $value =~ s{\s+\Z}{}xms;
    return lc($key) . '=' . lc($value);
}

__END__

=head1 NAME

ldap-git-backup - check in LDIF from an LDAP server into a GIT repository

=head1 SYNOPSIS

ldap-git-backup [options]

ldap-git-backup --help

=head1 DESCRIPTION

ldap-git-backup takes an LDIF dump of an LDAP server and updates a GIT repository
that serves as a versioned backup.

ldap-git-backup splits the LDIF data into separate entries.  It constructs
unique but stable file names using a combination of the creation time stamp for
ordering and the DN as the unique key for an entry.

=head1 OPTIONS

=over 4

=item B<--ldif-cmd <dump_ldif_command>>

Specify a command to create a complete LDIF dump of the LDAP directory suitable
for a backup.  It should contain all entries necessary to restore the LDAP
database.  By default /usr/sbin/slapcat from OpenLDAP is taken.

=item B<--backup-dir <backup_directory>>

Specify the directory where the GIT repository for the versioned backup is held.
Default: /var/backup/ldap

=item B<--help>

Prints this page.

=back

=head1 AUTHOR

Elmar S. Heeb <elmar@heebs.ch>

=cut
